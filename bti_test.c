#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <setjmp.h>

volatile int err_expected = 0;
static jmp_buf jump_buffer;

void sigill_handler(int sig) {
    if (err_expected == 0) {
        printf("[-] Caught SIGILL when it was not expected. Inconclusive results\n");
        exit(1);
    }
    printf("[+] Caught SIGILL: BTI worked as expected\n");
    exit(0);
}

int target_function() {
    __asm__ volatile(
        "mov x0, #5\n"
        "ret\n"
        "mov x0, #123\n"
        "mov x0, #123\n" // Doubled, so that if BTI isn't generated by the compiler, the target function will still return 123
        "ret\n"
    );
}

int main() {
    // Set up SIGILL handler
    if (signal(SIGILL, sigill_handler) == SIG_ERR) {
        perror("Failed to set signal handler\n");
        exit(1);
    }

    int (*func_ptr)() = target_function;

    char *misaligned_ptr = (char *)func_ptr + (3 * 4); // Skip 3 instructions (BTI instruction, Mov, and Ret)
    int (*misaligned_func_ptr)() = (int (*)())misaligned_ptr;

    // Sanity check that the real pointer works
    int result = 0;
    result = func_ptr();
    if (result != 5) {
        perror("Something is fundamentally wrong\n");
        exit(1);
    } else {
        printf("[+] Normal function works as expected\n");
    }

    printf("[!] Attempting to run a gadget.. BTI should stop this!\n");
    fflush(stdout);

    // Use setjmp to return to this point if SIGILL is caught
    setjmp(jump_buffer);
    err_expected = 1;
    result = misaligned_func_ptr();
    err_expected = 0;
    printf("[-] BTI Did not prevent calling a misaligned function!\n");
    if (result == 123) {
        printf("[-] Gadget executed successfully: BTI is not working\n");
        exit(0);
    } else {
        printf("[-] Gadget executed wrong, troubleshoot this.\n");
    }

    return 0;
}
